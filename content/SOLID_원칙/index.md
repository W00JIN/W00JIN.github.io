---
emoji: 🦖
title: SOLID 원칙
date: '2022-04-15 00:28:00'
author: 우진
tags: blog
categories: JAVA DESIGN_PATTERN
---

<br/>

## 1) SRP(Single Responsibility Principle) 단일 책임 원칙

객체에 한가지 ` 책임 `만을 할당해야 하며, 해당 책임을 유일하게 가지고 있어야 함

“클래스를 변경하는 이유는 단 한 개여야 한다”라고 표현하기도 함 (회귀 테스트를 통해 평가 가능)

<br/>

❗️ 책임을 구분짓는 중요한 기준 : ` 변경 `

변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것

<br/>


### 🥎 SRP 원칙의 장점

**높은 응집도** - 응집도가 높으면 관련 기능이 한 클래스에 모여있어 유지 보수, 재사용이 쉽다

**낮은 결합도** - 결합도가 낮으면 변경에 영향을 받는 클래스들이 줄어들어 회귀 테스트에 용이

- 응집도 : 한 프로그램요소(클래스, 매서드)가 뭉쳐있는 척도
- 결합도 : 프로그램 구성 요소들 사이의 의존도를 나타내는 척도

<br/>


### 🥎 SRP 원칙을 지키지 않았을 때 문제점

**1) 유지보수가 어려움**

` “책임 = 변경사유” ` 책임의 개수가 많으면 다른 객체에 주는 영향이 커지므로 사소한 변경으로도 대대적인 수정 필요

클래스가 담당하는 변경사유가 많다면 각 변경마다 연결된 모든 클래스를 점검해야함

코드를 절차 지향적으로 변하게 하여 유지 보수를 엉망으로 만드는 것

**2) 재사용이 어려움**

책임의 개수가 많으면 책임 하나의 기능만이 필요한 경우 클래스를 추가로 생성해야 함

<br/>


### 🥎 SRP 원칙 적용 방법

**1) 책임 분리 : 한 클래스가 여러 책임을 가지는 경우**

변경 사유를 구분하여 각 사유(책임)를 담당하는 클래스로 책임을 분리시킴 → 설계가 변화될 때 변경 범위 줄어듦

객체를 추상화한 클래스 / 데이터를 엑세스하는 DAO 클래스 / 데이터를 입출력 하는 클래스로 구분

<br/>

**2) 산탄총 수술 : 한 책임이 여러 클래스에 분산된 경우**

ex) 로깅, 보안, 트랜잭션과 같은 횡단 관심으로 분류할 수 있는 기능(책임)

책임이 분산된 모든 클래스를 찾아야 하기 때문에 위험

부가기능을 별개의 클래스로 분리해 책임을 담당시킴 → 흩어진 공동 책임을 한 클래스에 모아 응집도를 높임

<br/>

**3) AOP(Aspect-Oriented Programming) 관심지향 프로그래밍 : 횡단 관심 문제 해결**

횡단 관심을 수행하는 코드를 애스펙트라는 객체로 모듈화 하여 위빙 작업을 통해 핵심 기능에 끼워넣음

이를 통해 기존 코드를 전혀 변경하지 않고도 시스템 핵심 기능에서 필요한 부가 기능을 효과적으로 이용 가능

횡단 관심에 변경이 생기면 해당 애스펙트만 수정하면 됨

<br/>

---

<br/>

## 2) OCP(Open-Closed Principle) 개방-폐쇄 원칙


> ❗ **객체 지향 프로그래밍의 핵심 원칙**


` 변경에는 닫혀 있어야 하고, 확장에는 열려 있어야 한다 `

클래스를 변경하지 않고도(Closed) 대상 클래스의 환경을 변경할 수 있는(Open) 설계

But 남용되면 불필요한 복잡성 야기

<br/>


### 🥎 OCP 원칙의 장점

- **유연성** - 변화하는 부분을 추상화함으로써 기존 코드를 수정하지 않고 확장 가능

- **재사용성** - 변경에 닫혀있기 때문에 새로운 모듈을 추가하더라도 기존 모듈은 변경되지 않고 재사용 가능

- **유지보수성** - 하나의 변경이 연쇄적인 다른 클래스의 변경으로 이어지는 것 방지

- **구현체를 주입한 테스트 가능**

<br/>


### 🥎 OCP 원칙을 지키지 않았을 때 문제점

- **구현에 의존** - “기능” 변경을 위해 코드를 수정해야 함

- **변경에 열림** - 연쇄적인 변경 야기 (유지보수가 어렵고, 재사용이 힘들며, 유연성이 떨어짐)

<br/>


### 🥎 OCP 원칙이 지켜지지 않는 경우

**if-else / 다운캐스팅**

<br/>


### 🥎 OCP 원칙 적용 방법

**1) 추상화 ⭐️**

1) ` 변경(확장)될 것과 변하지 않을 것을 엄격히 구분 ` (❗️ OCP 설계의 키포인트)

2) 이 두 모듈이 만나는 지점에 인터페이스를 추상화

**2) 다형성**

구현에 의존하지 않고 정의한 인터페이스에 의존하도록 캡슐화

**3) 상속 & 오버라이딩** 

상위클래스가 바뀌면 하위클래스에 끼치는 영향이 큼

<br/>


### 🥎 Spring에서 OCP 위반

인터페이스를 정의하고 구현체를 만들더라도 구현체를 변경하려면 소스 수정이 필요 

⇒ 변경에 닫혀있지 않고 수정이 필요하게 됨 ❗️ OCP 위반

<br/>

new GenesisGv80() → new TeslaModel3()

```java
public class Ride {

	private Car car = new TeslaModel3(); // new GenesisGv80();

}
```

<br/>


### 🥎 Spring에서 OCP 위반 해결 방법

객체를 생성하고 연관 관계를 맺어주는 별도의 조립, 설정자 필요 (Spring 컨테이너)

` DI 의존성 주입, IoC ` - 인스턴스 실행 시점에 외부에서 생성자 / setter 을 이용해 주입 

```java
public class Ride {

	private Car car;

	public Ride(Car car){
		this.car = car;
	}

	public setCar(Car car){
		this.car = car;
	}

}
```

<br/>

---

<br/>

## 3) LSP(Liskov Substitution Principle) 리스코프 치환 원칙

- 일반화 관계에서 부모 클래스와 자식 클래스 사이의 행위가 일관성이 있어야 함
- 정해진 인터페이스 규약을 보장해야 함
- 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 함

<br/>


### 🥎 LSP 원칙을 지키지 않았을 때 문제점

오리너구리는 포유류의 일종이지만 새끼를 낳지 않고, 알을 낳음

⇒ 부모, 자식 클래스간 행위가 일관적이지 않음

<br/>

오리너구리가 포유류 인터페이스를 상속받는다면, breed 메서드를 실행 시 오리너구리가 태어난 시점이 아닌 알을 낳은 시점으로 생일이 정해진다. 이는 컴파일 시점에 발견하지 못한 내부적 오류를 야기할 수 있다. (LSP는 단순히 컴파일 시점의 오류를 이야기하는 것이 아님)

```java
public void breed(Mammal mammal){
	baby.setBirthDay();
}
```

<br/>

이를 지키기 위해서는 **instanceof**를 통해 타입을 비교하고, 예외 처리를 해주어야 하며 기능 확장이 어려워지기 때문에 OCP또한 위반하게 된다


<br/>

> ❗️ LSP가 지켜키지 않으면 기능 확장이 어려워져 OCP를 위반

<br/>

--- 

<br/>

## 4) ISP(Interface Segregation Principle) 인터페이스 분리 원칙

클라이언트는 자신이 사용하는 메소드에만 의존해야 함

→ 인터페이스를 클라이언트에 특화되도록 분리시켜야 함(범용X)

<br/>

클라이언트 기준으로 인터페이스를 분리하면 인터페이스가 명확해지고, 대체 가능성이 높아짐

다른 클라이언트의 변경이 인터페이스에 영향을 미치지 않음

<br/>

---

<br/>

## 5) DIP(Dependency Inversion Principle) 의존 역전 원칙

구현이 아닌 추상에 의존해야 함

→ 클라이언트 코드가 구현 클래스를 바라보는 것이 아닌 인터페이스를 바라보도록 설계해야 함

<br/>

---
## References

[스프링 핵심 원리 - 기본편 (김영한)](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8)

[자바 객체지향 디자인 패턴 (정인상, 채흥석)](http://www.yes24.com/Product/Goods/12501269)

<br/>

---