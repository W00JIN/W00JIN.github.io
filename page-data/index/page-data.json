{
    "componentChunkName": "component---src-pages-index-js",
    "path": "/",
    "result": {"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"38593f39-f337-59ed-8feb-4823c0657130","excerpt":"백준 23289 온풍기 안녕! 🥎 구현 과정 온풍기, 대각선, 벽 방향 설정 입력값에 따른 온풍기 방향, 벽 방향 저장 온풍기 작동 구현 온도 조절 온도 체크 - 종료조건 🥎 0) 문제 분석   에 저장되는 정보를 구조체로 구현한다. 주어지는 정보 : 온풍기 유무와 방향, 온도, 벽  : 온풍기 방향 (0이면 온풍기가 없는 칸)  : 한 칸을 기준으로 상, 하, 좌, 우의 벽을 저장 (🔥 중복해서 벽 존재 가능하기 때문에 vector로 구현)  : 해당 칸의 온도 온풍기의 퍼져나가는 바람은 를 사용하여 바람이 이동할 칸을 저장, 칸마다 세번씩 탐색한다. 순차적으로 퍼져나가며 3번 탐색해야 하기 때문에 선입선출 자료구조인 를 사용. 온풍기의 바람이 퍼져나갈 때 온도가 5부터 1까지로 감소하며 이동하기 때문에 depth를 저장하기 위한  구조체도 선언한다.  🥎 1) 온풍기, 대각선, 벽 방향 설정 문제에서 주어지는 은 다음과 같다. 1: 방향이 오른쪽 2: 방향이 왼쪽 3: 방향이 …","frontmatter":{"categories":"Problem_Solving","title":"백준 23289 온풍기 안녕!","date":"May 12, 2022"},"fields":{"slug":"/백준_온풍기안녕/"}}},{"node":{"id":"7a8101a6-0aea-5704-8b0f-b918061995bf","excerpt":"🥎 상태 머신 다이어그램 (State Machine Diagram) UML에서 상태와  시작 상태 : 검은 동그라미 / 상태 : 모서리가 둥근 사각형 / 상태전이 : 화살표 상태 객체가 시스템에 존재하는 라이프타임 동안 객체가 가질 수 있는 조건이나 상황 시작 상태 : 객체가 시작하는 처음 상태 시작 상태에서의 진입은 객체 생성 또는 명시 X 상태 진입 객체의 한 상태에서 다른 상태로 이동하는 것 특정 이벤트 발생 후 명세 조건을 만족한 경우에 이루어짐 ‘이벤트(인자 리스트)[조건]/액션’으로 명세, ‘/’ 다음에 진입 후 수행되어야 하는 액션 기술 🥎 형광등 만들기 상태 머신 다이어그램 상태 : ON, OFF  상태 : ON, OFF, SLEEPING  if-else 조건문으로 구현하는 경우의 문제점 복잡한 조건문으로 상태 변화의 이해 어려움 새로운 상태 추가 시 모든 메서드 수정 필요 🥎 코드 Light.java Client.java 🥎 State Pattern : 상태에 따라…","frontmatter":{"categories":"DESIGN_PATTERN","title":"스테이트 패턴 (State Pattern)","date":"April 20, 2022"},"fields":{"slug":"/스테이트_패턴/"}}},{"node":{"id":"f0b06594-fb37-591f-942b-1be1dd3b60ff","excerpt":"🥎 도로 표시 방법 조합하기 내비게이션 SW에서 도로 표시 기능과 추가 옵션인 차선 표시 기능 설계 추가 옵션인 차선표시 기능은 RoadDisplay을 상속받아 draw() 메서드를 오버라이드  - RoadDisplay  - RoadDisplayWithLane extends RoadDisplay  🥎 문제점 또다른 도로표시 기능을 추가로 구현하고싶다면? 여러가지 추가기능을 조합해 사용하고 싶다면? 🥎 또다른 도로표시 기능 추가 구현  🥎 여러 추가 기능 조합 도로표시의 을 RoadDisplay 클래스를 상속받는 것은 적절한 설계이나,\n여러 조합을 구현할 때 상속을 통한 기능 확장은 조합 별로 하위 클래스를 구현해야 함 →  : 중복하여 생성되는 메서드 존재, 추가기능의 부분집합 개수만큼 클래스 생성 필요 (2의 n제곱)  🥎 해결책 추가 기능별로 개별적인 클래스를 설계 → 기능을 조합할 때 클래스의 객체를 이용\n추가 기능의 수가 많을수록 효과가 큰 설계 (2의 n제곱 → n+2) …","frontmatter":{"categories":"DESIGN_PATTERN","title":"데커레이터 패턴 (Decorator Pattern)","date":"April 17, 2022"},"fields":{"slug":"/데커레이터_패턴/"}}},{"node":{"id":"e9948b10-9072-5e44-870c-2de7191141f1","excerpt":"1) 컴포넌트 스캔과 의존관계 자동 주입 🥎 컴포넌트 스캔 : 설정정보가 없어도 자동으로 스프링 빈을 등록하는 기능 스프링 빈 누락 방지 설정에 소요하는 시간, 설정정보 크기 감소 🥎 @ComponentScan 어노테이션 사용 : 자동으로 스프링 빈을 등록하는 설정파일 명시 @Bean으로 등록된 설정 정보가 존재하지 않음 @Component 어노테이션이 붙은 모든 클래스를 스프링 빈으로 등록  : 클래스명의 맨 앞글자를 소문자로 변경  : @Component(”지정할 빈 이름”) 형태로 지정 🥎 @Component 어노테이션 사용 : Scan될 컴포넌트를 명시 @ComponentScan 어노테이션에 의해 클래스가 스캔됨 🥎 @Autowired 어노테이션 사용 : 의존관계 자동 주입 의존관계를 직접 명시할 설정파일을 대신하여 자동으로 의존관계 주입 생성자에서 여러 의존관계도 한번에 주입 가능 생성자에 @Autowired 를 지정하면, 스프링 컨테이너가 자동으로 해당 스프링 빈을 찾아…","frontmatter":{"categories":"Spring","title":"Spring 컴포넌트 스캔","date":"April 16, 2022"},"fields":{"slug":"/컴포넌트_스캔/"}}},{"node":{"id":"e7b17bcd-98c7-50ab-a1a9-3c7226b78d0e","excerpt":"1) SRP(Single Responsibility Principle) 단일 책임 원칙 객체에 한가지 만을 할당해야 하며, 해당 책임을 유일하게 가지고 있어야 함 “클래스를 변경하는 이유는 단 한 개여야 한다”라고 표현하기도 함 (회귀 테스트를 통해 평가 가능) ❗️ 책임을 구분짓는 중요한 기준 :  변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것 🥎 SRP 원칙의 장점 높은 응집도 - 응집도가 높으면 관련 기능이 한 클래스에 모여있어 유지 보수, 재사용이 쉽다 낮은 결합도 - 결합도가 낮으면 변경에 영향을 받는 클래스들이 줄어들어 회귀 테스트에 용이 응집도 : 한 프로그램요소(클래스, 매서드)가 뭉쳐있는 척도 결합도 : 프로그램 구성 요소들 사이의 의존도를 나타내는 척도 🥎 SRP 원칙을 지키지 않았을 때 문제점 1) 유지보수가 어려움  책임의 개수가 많으면 다른 객체에 주는 영향이 커지므로 사소한 변경으로도 대대적인 수정 필요 클래스가 담당하는 변경사유가 많다면…","frontmatter":{"categories":"JAVA DESIGN_PATTERN","title":"SOLID 원칙","date":"April 15, 2022"},"fields":{"slug":"/SOLID_원칙/"}}},{"node":{"id":"6306ed9c-8217-5598-9fec-bf3323bc2c70","excerpt":"👋 개발 블로그 시작 개발 공부를 하며 TIL(Today I Learn)을 기록할 블로그를 탐색했다. Velog, Tistroy, Mideum 등 다양한 플랫폼이 있지만.. 내 취향대로 커스터마이징 가능한 Github blog가 눈에 들어왔다.\n그리하여 탄생한 나의 첫 블로그. 생각한 걸 글로 적는 과정이 아직은 낯설지만 애정이 많이 간다. 앞으로 매일 공부한 걸 기록하고싶다!\n 🚀 Why Gatsby? Gatsby를 선택한 이유는 간단하다. React.js 기반의 프로젝트를 진행했었고, 블로그 테마를 사용하며 소스를 분석해보면 분명 나에게 도움이 될 것 같았기 때문이다.\n선택한 테마는 zoomkoding-gatsby-blog 움직이는 미모지가 내 마음도 움직였다. (라임 좋았다-⭐️) Gatsby 외에도 Ruby 기반의 Jekyll도 이용 가능하니 참고하면 좋을듯 하다.","frontmatter":{"categories":"블로그","title":"개발 블로그 시작","date":"April 14, 2022"},"fields":{"slug":"/개발_블로그_시작/"}}}]},"site":{"siteMetadata":{"language":"ko","author":{"name":"장우진","bio":{"role":"개발자","description":["성장하는","매일 공부하는","Back-end"],"thumbnail":"profile.gif"},"social":{"github":"https://github.com/W00JIN","linkedIn":"","email":"woojin16_@naver.com"}}}}},"pageContext":{}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437","3350743975"]}