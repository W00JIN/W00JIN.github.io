{
    "componentChunkName": "component---src-pages-index-js",
    "path": "/",
    "result": {"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"f0b06594-fb37-591f-942b-1be1dd3b60ff","excerpt":"🥎 도로 표시 방법 조합하기 내비게이션 SW에서 도로 표시 기능과 추가 옵션인 차선 표시 기능 설계 추가 옵션인 차선표시 기능은 RoadDisplay을 상속받아 draw() 메서드를 오버라이드  - RoadDisplay  - RoadDisplayWithLane extends RoadDisplay  🥎 문제점 또다른 도로표시 기능을 추가로 구현하고싶다면? 여러가지 추가기능을 조합해 사용하고 싶다면? 🥎 또다른 도로표시 기능 추가 구현  🥎 여러 추가 기능 조합 도로표시의 을 RoadDisplay 클래스를 상속받는 것은 적절한 설계이나,\n여러 조합을 구현할 때 상속을 통한 기능 확장은 조합 별로 하위 클래스를 구현해야 함 →  : 중복하여 생성되는 메서드 존재, 추가기능의 부분집합 개수만큼 클래스 생성 필요 (2의 n제곱)  🥎 해결책 추가 기능별로 개별적인 클래스를 설계 → 기능을 조합할 때 클래스의 객체를 이용\n추가 기능의 수가 많을수록 효과가 큰 설계 (2의 n제곱 → n+2) …","frontmatter":{"categories":"DESIGN_PATTERN","title":"데커레이터 페턴 (Decorator Pattern)","date":"April 17, 2022"},"fields":{"slug":"/데커레이터_패턴/"}}},{"node":{"id":"e9948b10-9072-5e44-870c-2de7191141f1","excerpt":"1) 컴포넌트 스캔과 의존관계 자동 주입 🥎 컴포넌트 스캔 : 설정정보가 없어도 자동으로 스프링 빈을 등록하는 기능 스프링 빈 누락 방지 설정에 소요하는 시간, 설정정보 크기 감소 🥎 @ComponentScan 어노테이션 사용 : 자동으로 스프링 빈을 등록하는 설정파일 명시 @Bean으로 등록된 설정 정보가 존재하지 않음 @Component 어노테이션이 붙은 모든 클래스를 스프링 빈으로 등록  : 클래스명의 맨 앞글자를 소문자로 변경  : @Component(”지정할 빈 이름”) 형태로 지정 🥎 @Component 어노테이션 사용 : Scan될 컴포넌트를 명시 @ComponentScan 어노테이션에 의해 클래스가 스캔됨 🥎 @Autowired 어노테이션 사용 : 의존관계 자동 주입 의존관계를 직접 명시할 설정파일을 대신하여 자동으로 의존관계 주입 생성자에서 여러 의존관계도 한번에 주입 가능 생성자에 @Autowired 를 지정하면, 스프링 컨테이너가 자동으로 해당 스프링 빈을 찾아…","frontmatter":{"categories":"Spring","title":"Spring 컴포넌트 스캔","date":"April 16, 2022"},"fields":{"slug":"/컴포넌트_스캔/"}}},{"node":{"id":"e7b17bcd-98c7-50ab-a1a9-3c7226b78d0e","excerpt":"1) SRP(Single Responsibility Principle) 단일 책임 원칙 객체에 한가지 만을 할당해야 하며, 해당 책임을 유일하게 가지고 있어야 함 “클래스를 변경하는 이유는 단 한 개여야 한다”라고 표현하기도 함 (회귀 테스트를 통해 평가 가능) ❗️ 책임을 구분짓는 중요한 기준 :  변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것 🥎 SRP 원칙의 장점 높은 응집도 - 응집도가 높으면 관련 기능이 한 클래스에 모여있어 유지 보수, 재사용이 쉽다 낮은 결합도 - 결합도가 낮으면 변경에 영향을 받는 클래스들이 줄어들어 회귀 테스트에 용이 응집도 : 한 프로그램요소(클래스, 매서드)가 뭉쳐있는 척도 결합도 : 프로그램 구성 요소들 사이의 의존도를 나타내는 척도 🥎 SRP 원칙을 지키지 않았을 때 문제점 1) 유지보수가 어려움  책임의 개수가 많으면 다른 객체에 주는 영향이 커지므로 사소한 변경으로도 대대적인 수정 필요 클래스가 담당하는 변경사유가 많다면…","frontmatter":{"categories":"JAVA DESIGN_PATTERN","title":"SOLID 원칙","date":"April 15, 2022"},"fields":{"slug":"/SOLID_원칙/"}}},{"node":{"id":"6306ed9c-8217-5598-9fec-bf3323bc2c70","excerpt":"👋 개발 블로그 시작 개발 공부를 하며 TIL(Today I Learn)을 기록할 블로그를 탐색했다. Velog, Tistroy, Mideum 등 다양한 플랫폼이 있지만.. 내 취향대로 커스터마이징 가능한 Github blog가 눈에 들어왔다.\n그리하여 탄생한 나의 첫 블로그. 생각한 걸 글로 적는 과정이 아직은 낯설지만 애정이 많이 간다. 앞으로 매일 공부한 걸 기록하고싶다!\n 🚀 Why Gatsby? Gatsby를 선택한 이유는 간단하다. React.js 기반의 프로젝트를 진행했었고, 블로그 테마를 사용하며 소스를 분석해보면 분명 나에게 도움이 될 것 같았기 때문이다.\n선택한 테마는 zoomkoding-gatsby-blog 움직이는 미모지가 내 마음도 움직였다. (라임 좋았다-⭐️) Gatsby 외에도 Ruby 기반의 Jekyll도 이용 가능하니 참고하면 좋을듯 하다.","frontmatter":{"categories":"블로그","title":"개발 블로그 시작","date":"April 14, 2022"},"fields":{"slug":"/개발_블로그_시작/"}}}]},"site":{"siteMetadata":{"language":"ko","author":{"name":"장우진","bio":{"role":"개발자","description":["성장하는","매일 공부하는","Back-end"],"thumbnail":"profile.gif"},"social":{"github":"https://github.com/W00JIN","linkedIn":"","email":"woojin16_@naver.com"}}}}},"pageContext":{}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437","3350743975"]}