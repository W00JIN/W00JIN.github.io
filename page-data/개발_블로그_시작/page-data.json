{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/개발_블로그_시작/",
    "result": {"data":{"cur":{"id":"6306ed9c-8217-5598-9fec-bf3323bc2c70","html":"<h2 id=\"-개발-블로그-시작\" style=\"position:relative;\"><a href=\"#-%EA%B0%9C%EB%B0%9C-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%8B%9C%EC%9E%91\" aria-label=\" 개발 블로그 시작 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>👋 개발 블로그 시작</h2>\n<p>개발 공부를 하며 TIL(Today I Learn)을 기록할 블로그를 탐색했다. Velog, Tistroy, Mideum 등 다양한 플랫폼이 있지만.. 내 취향대로 커스터마이징 가능한 Github blog가 눈에 들어왔다.\n그리하여 탄생한 나의 첫 블로그. 생각한 걸 글로 적는 과정이 아직은 낯설지만 애정이 많이 간다. 앞으로 매일 공부한 걸 기록하고싶다!\n<br/><br/></p>\n<h3 id=\"-why-gatsby\" style=\"position:relative;\"><a href=\"#-why-gatsby\" aria-label=\" why gatsby permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🚀 Why Gatsby?</h3>\n<p>Gatsby를 선택한 이유는 간단하다. React.js 기반의 프로젝트를 진행했었고, 블로그 테마를 사용하며 소스를 분석해보면 분명 나에게 도움이 될 것 같았기 때문이다.\n선택한 테마는 <a href=\"https://github.com/zoomKoding/zoomkoding-gatsby-blog\">zoomkoding-gatsby-blog</a> 움직이는 미모지가 내 마음도 움직였다. (라임 좋았다-⭐️)</p>\n<blockquote>\n<p>Gatsby 외에도 Ruby 기반의 Jekyll도 이용 가능하니 참고하면 좋을듯 하다.</p>\n</blockquote>\n<br/>\n<hr>","excerpt":"👋 개발 블로그 시작 개발 공부를 하며 TIL(Today I Learn)을 기록할 블로그를 탐색했다. Velog, Tistroy, Mideum 등 다양한 플랫폼이 있지만.. 내 취향대로 커스터마이징 가능한 Github blog가 눈에 들어왔다.\n그리하여 탄생한 나의 첫 블로그. 생각한 걸 글로 적는 과정이 아직은 낯설지만 애정이 많이 간다. 앞으로 매일 공부한 걸 기록하고싶다!\n 🚀 Why Gatsby? Gatsby를 선택한 이유는 간단하다. React.js 기반의 프로젝트를 진행했었고, 블로그 테마를 사용하며 소스를 분석해보면 분명 나에게 도움이 될 것 같았기 때문이다.\n선택한 테마는 zoomkoding-gatsby-blog 움직이는 미모지가 내 마음도 움직였다. (라임 좋았다-⭐️) Gatsby 외에도 Ruby 기반의 Jekyll도 이용 가능하니 참고하면 좋을듯 하다.","frontmatter":{"date":"April 14, 2022","title":"개발 블로그 시작","categories":"블로그","author":"우진","emoji":"🦖"},"fields":{"slug":"/개발_블로그_시작/"}},"next":null,"prev":{"id":"e7b17bcd-98c7-50ab-a1a9-3c7226b78d0e","html":"<br/>\n<h2 id=\"1-srpsingle-responsibility-principle-단일-책임-원칙\" style=\"position:relative;\"><a href=\"#1-srpsingle-responsibility-principle-%EB%8B%A8%EC%9D%BC-%EC%B1%85%EC%9E%84-%EC%9B%90%EC%B9%99\" aria-label=\"1 srpsingle responsibility principle 단일 책임 원칙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1) SRP(Single Responsibility Principle) 단일 책임 원칙</h2>\n<p>객체에 한가지 <code class=\"language-text\">책임</code>만을 할당해야 하며, 해당 책임을 유일하게 가지고 있어야 함</p>\n<p>“클래스를 변경하는 이유는 단 한 개여야 한다”라고 표현하기도 함 (회귀 테스트를 통해 평가 가능)</p>\n<br/>\n<p>❗️ 책임을 구분짓는 중요한 기준 : <code class=\"language-text\">변경</code></p>\n<p>변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것</p>\n<br/>\n<h3 id=\"-srp-원칙의-장점\" style=\"position:relative;\"><a href=\"#-srp-%EC%9B%90%EC%B9%99%EC%9D%98-%EC%9E%A5%EC%A0%90\" aria-label=\" srp 원칙의 장점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🥎 SRP 원칙의 장점</h3>\n<p><strong>높은 응집도</strong> - 응집도가 높으면 관련 기능이 한 클래스에 모여있어 유지 보수, 재사용이 쉽다</p>\n<p><strong>낮은 결합도</strong> - 결합도가 낮으면 변경에 영향을 받는 클래스들이 줄어들어 회귀 테스트에 용이</p>\n<ul>\n<li>응집도 : 한 프로그램요소(클래스, 매서드)가 뭉쳐있는 척도</li>\n<li>결합도 : 프로그램 구성 요소들 사이의 의존도를 나타내는 척도</li>\n</ul>\n<br/>\n<h3 id=\"-srp-원칙을-지키지-않았을-때-문제점\" style=\"position:relative;\"><a href=\"#-srp-%EC%9B%90%EC%B9%99%EC%9D%84-%EC%A7%80%ED%82%A4%EC%A7%80-%EC%95%8A%EC%95%98%EC%9D%84-%EB%95%8C-%EB%AC%B8%EC%A0%9C%EC%A0%90\" aria-label=\" srp 원칙을 지키지 않았을 때 문제점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🥎 SRP 원칙을 지키지 않았을 때 문제점</h3>\n<p><strong>1) 유지보수가 어려움</strong></p>\n<p><code class=\"language-text\">“책임 = 변경사유”</code> 책임의 개수가 많으면 다른 객체에 주는 영향이 커지므로 사소한 변경으로도 대대적인 수정 필요</p>\n<p>클래스가 담당하는 변경사유가 많다면 각 변경마다 연결된 모든 클래스를 점검해야함</p>\n<p>코드를 절차 지향적으로 변하게 하여 유지 보수를 엉망으로 만드는 것</p>\n<p><strong>2) 재사용이 어려움</strong></p>\n<p>책임의 개수가 많으면 책임 하나의 기능만이 필요한 경우 클래스를 추가로 생성해야 함</p>\n<br/>\n<h3 id=\"-srp-원칙-적용-방법\" style=\"position:relative;\"><a href=\"#-srp-%EC%9B%90%EC%B9%99-%EC%A0%81%EC%9A%A9-%EB%B0%A9%EB%B2%95\" aria-label=\" srp 원칙 적용 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🥎 SRP 원칙 적용 방법</h3>\n<p><strong>1) 책임 분리 : 한 클래스가 여러 책임을 가지는 경우</strong></p>\n<p>변경 사유를 구분하여 각 사유(책임)를 담당하는 클래스로 책임을 분리시킴 → 설계가 변화될 때 변경 범위 줄어듦</p>\n<p>객체를 추상화한 클래스 / 데이터를 엑세스하는 DAO 클래스 / 데이터를 입출력 하는 클래스로 구분</p>\n<br/>\n<p><strong>2) 산탄총 수술 : 한 책임이 여러 클래스에 분산된 경우</strong></p>\n<p>ex) 로깅, 보안, 트랜잭션과 같은 횡단 관심으로 분류할 수 있는 기능(책임)</p>\n<p>책임이 분산된 모든 클래스를 찾아야 하기 때문에 위험</p>\n<p>부가기능을 별개의 클래스로 분리해 책임을 담당시킴 → 흩어진 공동 책임을 한 클래스에 모아 응집도를 높임</p>\n<br/>\n<p><strong>3) AOP(Aspect-Oriented Programming) 관심지향 프로그래밍 : 횡단 관심 문제 해결</strong></p>\n<p>횡단 관심을 수행하는 코드를 애스펙트라는 객체로 모듈화 하여 위빙 작업을 통해 핵심 기능에 끼워넣음</p>\n<p>이를 통해 기존 코드를 전혀 변경하지 않고도 시스템 핵심 기능에서 필요한 부가 기능을 효과적으로 이용 가능</p>\n<p>횡단 관심에 변경이 생기면 해당 애스펙트만 수정하면 됨</p>\n<br/>\n<hr>\n<br/>\n<h2 id=\"2-ocpopen-closed-principle-개방-폐쇄-원칙\" style=\"position:relative;\"><a href=\"#2-ocpopen-closed-principle-%EA%B0%9C%EB%B0%A9-%ED%8F%90%EC%87%84-%EC%9B%90%EC%B9%99\" aria-label=\"2 ocpopen closed principle 개방 폐쇄 원칙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2) OCP(Open-Closed Principle) 개방-폐쇄 원칙</h2>\n<blockquote>\n<p>❗ <strong>객체 지향 프로그래밍의 핵심 원칙</strong></p>\n</blockquote>\n<p><code class=\"language-text\">변경에는 닫혀 있어야 하고, 확장에는 열려 있어야 한다</code></p>\n<p>클래스를 변경하지 않고도(Closed) 대상 클래스의 환경을 변경할 수 있는(Open) 설계</p>\n<p>But 남용되면 불필요한 복잡성 야기</p>\n<br/>\n<h3 id=\"-ocp-원칙의-장점\" style=\"position:relative;\"><a href=\"#-ocp-%EC%9B%90%EC%B9%99%EC%9D%98-%EC%9E%A5%EC%A0%90\" aria-label=\" ocp 원칙의 장점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🥎 OCP 원칙의 장점</h3>\n<ul>\n<li>\n<p><strong>유연성</strong> - 변화하는 부분을 추상화함으로써 기존 코드를 수정하지 않고 확장 가능</p>\n</li>\n<li>\n<p><strong>재사용성</strong> - 변경에 닫혀있기 때문에 새로운 모듈을 추가하더라도 기존 모듈은 변경되지 않고 재사용 가능</p>\n</li>\n<li>\n<p><strong>유지보수성</strong> - 하나의 변경이 연쇄적인 다른 클래스의 변경으로 이어지는 것 방지</p>\n</li>\n<li>\n<p><strong>구현체를 주입한 테스트 가능</strong></p>\n</li>\n</ul>\n<br/>\n<h3 id=\"-ocp-원칙을-지키지-않았을-때-문제점\" style=\"position:relative;\"><a href=\"#-ocp-%EC%9B%90%EC%B9%99%EC%9D%84-%EC%A7%80%ED%82%A4%EC%A7%80-%EC%95%8A%EC%95%98%EC%9D%84-%EB%95%8C-%EB%AC%B8%EC%A0%9C%EC%A0%90\" aria-label=\" ocp 원칙을 지키지 않았을 때 문제점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🥎 OCP 원칙을 지키지 않았을 때 문제점</h3>\n<ul>\n<li>\n<p><strong>구현에 의존</strong> - “기능” 변경을 위해 코드를 수정해야 함</p>\n</li>\n<li>\n<p><strong>변경에 열림</strong> - 연쇄적인 변경 야기 (유지보수가 어렵고, 재사용이 힘들며, 유연성이 떨어짐)</p>\n</li>\n</ul>\n<br/>\n<h3 id=\"-ocp-원칙이-지켜지지-않는-경우\" style=\"position:relative;\"><a href=\"#-ocp-%EC%9B%90%EC%B9%99%EC%9D%B4-%EC%A7%80%EC%BC%9C%EC%A7%80%EC%A7%80-%EC%95%8A%EB%8A%94-%EA%B2%BD%EC%9A%B0\" aria-label=\" ocp 원칙이 지켜지지 않는 경우 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🥎 OCP 원칙이 지켜지지 않는 경우</h3>\n<p><strong>if-else / 다운캐스팅</strong></p>\n<br/>\n<h3 id=\"-ocp-원칙-적용-방법\" style=\"position:relative;\"><a href=\"#-ocp-%EC%9B%90%EC%B9%99-%EC%A0%81%EC%9A%A9-%EB%B0%A9%EB%B2%95\" aria-label=\" ocp 원칙 적용 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🥎 OCP 원칙 적용 방법</h3>\n<p><strong>1) 추상화 ⭐️</strong></p>\n<ol>\n<li>\n<p><code class=\"language-text\">변경(확장)될 것과 변하지 않을 것을 엄격히 구분</code> (❗️ OCP 설계의 키포인트)</p>\n</li>\n<li>\n<p>이 두 모듈이 만나는 지점에 인터페이스를 추상화</p>\n</li>\n</ol>\n<p><strong>2) 다형성</strong></p>\n<p>구현에 의존하지 않고 정의한 인터페이스에 의존하도록 캡슐화</p>\n<p><strong>3) 상속 &#x26; 오버라이딩</strong></p>\n<p>상위클래스가 바뀌면 하위클래스에 끼치는 영향이 큼</p>\n<br/>\n<h3 id=\"-spring에서-ocp-위반\" style=\"position:relative;\"><a href=\"#-spring%EC%97%90%EC%84%9C-ocp-%EC%9C%84%EB%B0%98\" aria-label=\" spring에서 ocp 위반 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🥎 Spring에서 OCP 위반</h3>\n<p>인터페이스를 정의하고 구현체를 만들더라도 구현체를 변경하려면 소스 수정이 필요</p>\n<p>⇒ 변경에 닫혀있지 않고 수정이 필요하게 됨 ❗️ OCP 위반</p>\n<br/>\n<p>new GenesisGv80() → new TeslaModel3()</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Ride</span> <span class=\"token punctuation\">{</span>\n\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Car</span> car <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">TeslaModel3</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// new GenesisGv80();</span>\n\n<span class=\"token punctuation\">}</span></code></pre></div>\n<br/>\n<h3 id=\"-spring에서-ocp-위반-해결-방법\" style=\"position:relative;\"><a href=\"#-spring%EC%97%90%EC%84%9C-ocp-%EC%9C%84%EB%B0%98-%ED%95%B4%EA%B2%B0-%EB%B0%A9%EB%B2%95\" aria-label=\" spring에서 ocp 위반 해결 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🥎 Spring에서 OCP 위반 해결 방법</h3>\n<p>객체를 생성하고 연관 관계를 맺어주는 별도의 조립, 설정자 필요 (Spring 컨테이너)</p>\n<p><code class=\"language-text\">DI 의존성 주입, IoC</code> - 인스턴스 실행 시점에 외부에서 생성자 / setter 을 이용해 주입</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Ride</span> <span class=\"token punctuation\">{</span>\n\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Car</span> car<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">public</span> <span class=\"token class-name\">Ride</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Car</span> car<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>car <span class=\"token operator\">=</span> car<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\n\t<span class=\"token keyword\">public</span> <span class=\"token function\">setCar</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Car</span> car<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>car <span class=\"token operator\">=</span> car<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span></code></pre></div>\n<br/>\n<hr>\n<br/>\n<h2 id=\"3-lspliskov-substitution-principle-리스코프-치환-원칙\" style=\"position:relative;\"><a href=\"#3-lspliskov-substitution-principle-%EB%A6%AC%EC%8A%A4%EC%BD%94%ED%94%84-%EC%B9%98%ED%99%98-%EC%9B%90%EC%B9%99\" aria-label=\"3 lspliskov substitution principle 리스코프 치환 원칙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3) LSP(Liskov Substitution Principle) 리스코프 치환 원칙</h2>\n<ul>\n<li>일반화 관계에서 부모 클래스와 자식 클래스 사이의 행위가 일관성이 있어야 함</li>\n<li>정해진 인터페이스 규약을 보장해야 함</li>\n<li>상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 함</li>\n</ul>\n<br/>\n<h3 id=\"-lsp-원칙을-지키지-않았을-때-문제점\" style=\"position:relative;\"><a href=\"#-lsp-%EC%9B%90%EC%B9%99%EC%9D%84-%EC%A7%80%ED%82%A4%EC%A7%80-%EC%95%8A%EC%95%98%EC%9D%84-%EB%95%8C-%EB%AC%B8%EC%A0%9C%EC%A0%90\" aria-label=\" lsp 원칙을 지키지 않았을 때 문제점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🥎 LSP 원칙을 지키지 않았을 때 문제점</h3>\n<p>오리너구리는 포유류의 일종이지만 새끼를 낳지 않고, 알을 낳음</p>\n<p>⇒ 부모, 자식 클래스간 행위가 일관적이지 않음</p>\n<br/>\n<p>오리너구리가 포유류 인터페이스를 상속받는다면, breed 메서드를 실행 시 오리너구리가 태어난 시점이 아닌 알을 낳은 시점으로 생일이 정해진다. 이는 컴파일 시점에 발견하지 못한 내부적 오류를 야기할 수 있다. (LSP는 단순히 컴파일 시점의 오류를 이야기하는 것이 아님)</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">breed</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Mammal</span> mammal<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\tbaby<span class=\"token punctuation\">.</span><span class=\"token function\">setBirthDay</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<br/>\n<p>이를 지키기 위해서는 <strong>instanceof</strong>를 통해 타입을 비교하고, 예외 처리를 해주어야 하며 기능 확장이 어려워지기 때문에 OCP또한 위반하게 된다</p>\n<br/>\n<blockquote>\n<p>❗️ LSP가 지켜키지 않으면 기능 확장이 어려워져 OCP를 위반</p>\n</blockquote>\n<br/>\n<hr>\n<br/>\n<h2 id=\"4-ispinterface-segregation-principle-인터페이스-분리-원칙\" style=\"position:relative;\"><a href=\"#4-ispinterface-segregation-principle-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-%EB%B6%84%EB%A6%AC-%EC%9B%90%EC%B9%99\" aria-label=\"4 ispinterface segregation principle 인터페이스 분리 원칙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4) ISP(Interface Segregation Principle) 인터페이스 분리 원칙</h2>\n<p>클라이언트는 자신이 사용하는 메소드에만 의존해야 함</p>\n<p>→ 인터페이스를 클라이언트에 특화되도록 분리시켜야 함(범용X)</p>\n<br/>\n<p>클라이언트 기준으로 인터페이스를 분리하면 인터페이스가 명확해지고, 대체 가능성이 높아짐</p>\n<p>다른 클라이언트의 변경이 인터페이스에 영향을 미치지 않음</p>\n<br/>\n<hr>\n<br/>\n<h2 id=\"5-dipdependency-inversion-principle-의존-역전-원칙\" style=\"position:relative;\"><a href=\"#5-dipdependency-inversion-principle-%EC%9D%98%EC%A1%B4-%EC%97%AD%EC%A0%84-%EC%9B%90%EC%B9%99\" aria-label=\"5 dipdependency inversion principle 의존 역전 원칙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5) DIP(Dependency Inversion Principle) 의존 역전 원칙</h2>\n<p>구현이 아닌 추상에 의존해야 함</p>\n<p>→ 클라이언트 코드가 구현 클래스를 바라보는 것이 아닌 인터페이스를 바라보도록 설계해야 함</p>\n<br/>\n<hr>\n<h2 id=\"references\" style=\"position:relative;\"><a href=\"#references\" aria-label=\"references permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>References</h2>\n<p><a href=\"https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8\">스프링 핵심 원리 - 기본편 (김영한)</a></p>\n<p><a href=\"http://www.yes24.com/Product/Goods/12501269\">자바 객체지향 디자인 패턴 (정인상, 채흥석)</a></p>\n<br/>\n<hr>","frontmatter":{"date":"April 15, 2022","title":"SOLID 원칙","categories":"JAVA DESIGN_PATTERN","author":"우진","emoji":"🦖"},"fields":{"slug":"/SOLID_원칙/"}},"site":{"siteMetadata":{"siteUrl":"https://W00JIN.github.io","comments":{"utterances":{"repo":""}}}}},"pageContext":{"slug":"/개발_블로그_시작/","nextSlug":"","prevSlug":"/SOLID_원칙/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}