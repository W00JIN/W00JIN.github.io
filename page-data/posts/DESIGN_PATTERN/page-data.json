{
    "componentChunkName": "component---src-templates-category-template-js",
    "path": "/posts/DESIGN_PATTERN",
    "result": {"pageContext":{"currentCategory":"DESIGN_PATTERN","categories":["All","DESIGN_PATTERN","Problem_Solving","Spring","JAVA","블로그"],"edges":[{"node":{"id":"ada5bd93-e349-57d6-a723-bb4a5e614ade","excerpt":"🥎 싱글턴 패턴 설계가 필요한 경우 : 스레드 풀, 캐시, 대화상자, 사용자 설정, 로그 기록 객체, 디바이스 드라이버 🥎 싱글턴 패턴 : 클래스 , 그 인스턴스로의 전역 접근을 제공하는 패턴 클래스 내에서 하나뿐인 인스턴스를 관리하도록 설계 다른 클래스에서의 인스턴스 생성을 막음 인스턴스가 필요하면 반드시 구현 클래스를 거쳐야 함 어디서든 접근 가능하게 전역 접근 지점 제공 lazy instantiation 방식으로 인스턴스를 생성하므로 자원을 많이 사용하는 경우 유용  : 프로그램 실행 시 메모리에 올라가므로 사용하지 않는 순간에도 자원을 차지 → 싱글턴 패턴을 사용하면 필요할 때만 객체 생성 가능 🥎 고전적인 싱글턴 패턴 구현 방법 클래스 내부에서만 인스턴스를 생성 가능하게  에서 인스턴스 변수에 인스턴스를 생성해 리턴 🥎 멀티쓰레딩 문제 멀티 쓰레드를 사용하면 uniqueInstance에 유일한 인스턴스가 생성되기 직전에 두 쓰레드에서 if(uniqueInstance == …","fields":{"slug":"/싱글턴_패턴/"},"frontmatter":{"categories":"DESIGN_PATTERN","title":"싱글턴 패턴 (Singleton Pattern)","date":"May 16, 2022"}},"next":{"fields":{"slug":"/백준_온풍기안녕/"}},"previous":null},{"node":{"id":"7a8101a6-0aea-5704-8b0f-b918061995bf","excerpt":"🥎 상태 머신 다이어그램 (State Machine Diagram) UML에서 상태와  시작 상태 : 검은 동그라미 / 상태 : 모서리가 둥근 사각형 / 상태전이 : 화살표 상태 객체가 시스템에 존재하는 라이프타임 동안 객체가 가질 수 있는 조건이나 상황 시작 상태 : 객체가 시작하는 처음 상태 시작 상태에서의 진입은 객체 생성 또는 명시 X 상태 진입 객체의 한 상태에서 다른 상태로 이동하는 것 특정 이벤트 발생 후 명세 조건을 만족한 경우에 이루어짐 ‘이벤트(인자 리스트)[조건]/액션’으로 명세, ‘/’ 다음에 진입 후 수행되어야 하는 액션 기술 🥎 형광등 만들기 상태 머신 다이어그램 상태 : ON, OFF  상태 : ON, OFF, SLEEPING  if-else 조건문으로 구현하는 경우의 문제점 복잡한 조건문으로 상태 변화의 이해 어려움 새로운 상태 추가 시 모든 메서드 수정 필요 🥎 코드 Light.java Client.java 🥎 State Pattern : 상태에 따라…","fields":{"slug":"/스테이트_패턴/"},"frontmatter":{"categories":"DESIGN_PATTERN","title":"스테이트 패턴 (State Pattern)","date":"April 20, 2022"}},"next":{"fields":{"slug":"/데커레이터_패턴/"}},"previous":{"fields":{"slug":"/백준_온풍기안녕/"}}},{"node":{"id":"f0b06594-fb37-591f-942b-1be1dd3b60ff","excerpt":"🥎 도로 표시 방법 조합하기 내비게이션 SW에서 도로 표시 기능과 추가 옵션인 차선 표시 기능 설계 추가 옵션인 차선표시 기능은 RoadDisplay을 상속받아 draw() 메서드를 오버라이드  - RoadDisplay  - RoadDisplayWithLane extends RoadDisplay  🥎 문제점 또다른 도로표시 기능을 추가로 구현하고싶다면? 여러가지 추가기능을 조합해 사용하고 싶다면? 🥎 또다른 도로표시 기능 추가 구현  🥎 여러 추가 기능 조합 도로표시의 을 RoadDisplay 클래스를 상속받는 것은 적절한 설계이나,\n여러 조합을 구현할 때 상속을 통한 기능 확장은 조합 별로 하위 클래스를 구현해야 함 →  : 중복하여 생성되는 메서드 존재, 추가기능의 부분집합 개수만큼 클래스 생성 필요 (2의 n제곱)  🥎 해결책 추가 기능별로 개별적인 클래스를 설계 → 기능을 조합할 때 클래스의 객체를 이용\n추가 기능의 수가 많을수록 효과가 큰 설계 (2의 n제곱 → n+2) …","fields":{"slug":"/데커레이터_패턴/"},"frontmatter":{"categories":"DESIGN_PATTERN","title":"데커레이터 패턴 (Decorator Pattern)","date":"April 17, 2022"}},"next":{"fields":{"slug":"/컴포넌트_스캔/"}},"previous":{"fields":{"slug":"/스테이트_패턴/"}}},{"node":{"id":"e7b17bcd-98c7-50ab-a1a9-3c7226b78d0e","excerpt":"1) SRP(Single Responsibility Principle) 단일 책임 원칙 객체에 한가지 만을 할당해야 하며, 해당 책임을 유일하게 가지고 있어야 함 “클래스를 변경하는 이유는 단 한 개여야 한다”라고 표현하기도 함 (회귀 테스트를 통해 평가 가능) ❗️ 책임을 구분짓는 중요한 기준 :  변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것 🥎 SRP 원칙의 장점 높은 응집도 - 응집도가 높으면 관련 기능이 한 클래스에 모여있어 유지 보수, 재사용이 쉽다 낮은 결합도 - 결합도가 낮으면 변경에 영향을 받는 클래스들이 줄어들어 회귀 테스트에 용이 응집도 : 한 프로그램요소(클래스, 매서드)가 뭉쳐있는 척도 결합도 : 프로그램 구성 요소들 사이의 의존도를 나타내는 척도 🥎 SRP 원칙을 지키지 않았을 때 문제점 1) 유지보수가 어려움  책임의 개수가 많으면 다른 객체에 주는 영향이 커지므로 사소한 변경으로도 대대적인 수정 필요 클래스가 담당하는 변경사유가 많다면…","fields":{"slug":"/SOLID_원칙/"},"frontmatter":{"categories":"JAVA DESIGN_PATTERN","title":"SOLID 원칙","date":"April 15, 2022"}},"next":{"fields":{"slug":"/개발_블로그_시작/"}},"previous":{"fields":{"slug":"/컴포넌트_스캔/"}}}]}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}